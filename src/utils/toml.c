#ifndef TOML_PARSER_H_Y469ZFLB
#define TOML_PARSER_H_Y469ZFLB

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>

#include "toml.h"

typedef struct TOMLParser {} *pTOMLParser;

typedef struct TOMLToken {
  int token;
  char *marker;
  char *start;
  char *end;
  int line;
  char *lineStart;
  char *tokenStr;
} TOMLToken;

typedef struct TOMLParserState {
  TOMLTable *rootTable;
  TOMLTable *currentTable;
  int errorCode;
  TOMLError *errorObj;
  TOMLToken *token;
} TOMLParserState;

char *TOMLErrorStrings[] = {
  "TOML_SUCCESS",
  "TOML_ERROR_FILEIO",
  "TOML_ERROR_FATAL",
  "TOML_ERROR_TABLE_DEFINED",
  "TOML_ERROR_ENTRY_DEFINED",
  "TOML_ERROR_NO_VALUE",
  "TOML_ERROR_NO_EQ",
  "TOML_ERROR_INVALID_HEADER",
  "TOML_ERROR_ARRAY_MEMBER_MISMATCH"
};

char *TOMLErrorDescription[] = {
  NULL,
  "Error reading from/writing to file.",
  "Fatal error.",
  "Table is already defined.",
  "Entry is already defined.",
  "Missing valid value.",
  "Missing equal sign in table entry.",
  "Incomplete table header.",
  "Array member must be the same type as other members."
};

void * TOMLParserAlloc( void * (*malloc)( size_t ) );
void TOMLParserFree( void *, void (*free)( void * ) );
void TOMLParser( void *, int hTokenId, void *, TOMLParserState * );

int TOMLScan(char *p, int* token, TOMLToken * );

#ifdef __cplusplus
};
#endif

#endif /* end of include guard: TOML_PARSER_H_Y469ZFLB */
#define EOF                             1
#define COMMENT                         2
#define LEFT_SQUARE                     3
#define RIGHT_SQUARE                    4
#define ID_DOT                          5
#define EQ                              6
#define ID                              7
#define COMMA                           8
#define STRING                          9
#define NUMBER                         10
#define TRUE                           11
#define FALSE                          12
#define DATE                           13
/* Generated by re2c 0.16 on Tue Mar 26 14:09:31 2019 */

#define COUNTLINES \
  tokenData->end = p; \
  char *line = tokenData->start; \
  \
  line = strchr( line, '\n' ); \
  while ( line != NULL && line < tokenData->end ) { \
    tokenData->line++; \
    tokenData->lineStart = line + 1; \
  }
#define RETURNTOKEN( tokenid ) *token = tokenData->token = tokenid; \
  tokenData->end = p; \
  return tokenid != EOF

#define YYMARKER tokenData->marker
#define SKIP(x) { tokenData->start = p; goto yy0; }

int TOMLScan(char *p, int* token, TOMLToken *tokenData ) {
  tokenData->start = p;
yy0:

{
	char yych;
	unsigned int yyaccept = 0;
	yych = *p;
	switch (yych) {
	case 0x00:	goto yy3;
	case '\t':
	case '\r':
	case ' ':	goto yy5;
	case '\n':	goto yy8;
	case '"':	goto yy10;
	case '#':	goto yy12;
	case ',':	goto yy15;
	case '-':	goto yy17;
	case '.':	goto yy18;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy20;
	case '=':	goto yy22;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy24;
	case '[':	goto yy27;
	case ']':	goto yy29;
	case 'f':	goto yy31;
	case 't':	goto yy32;
	default:	goto yy2;
	}
yy2:
	p = YYMARKER;
	if (yyaccept == 0) {
		goto yy21;
	} else {
		goto yy34;
	}
yy3:
	++p;
	{ RETURNTOKEN( EOF ); }
yy5:
	++p;
	yych = *p;
	switch (yych) {
	case '\t':
	case '\r':
	case ' ':	goto yy5;
	default:	goto yy7;
	}
yy7:
	{ SKIP(); }
yy8:
	++p;
	{ tokenData->line++; tokenData->lineStart = p; SKIP(); }
yy10:
	++p;
	yych = *p;
	switch (yych) {
	case 0x00:	goto yy33;
	case '"':	goto yy35;
	case '\\':	goto yy37;
	default:	goto yy10;
	}
yy12:
	++p;
	yych = *p;
	switch (yych) {
	case 0x00:
	case '\n':	goto yy14;
	default:	goto yy12;
	}
yy14:
	{ RETURNTOKEN( COMMENT ); }
yy15:
	++p;
	{ RETURNTOKEN( COMMA ); }
yy17:
	yych = *++p;
	switch (yych) {
	case '.':	goto yy38;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy39;
	default:	goto yy2;
	}
yy18:
	++p;
	switch ((yych = *p)) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy41;
	default:	goto yy19;
	}
yy19:
	{ RETURNTOKEN( ID_DOT ); }
yy20:
	yyaccept = 0;
	yych = *(YYMARKER = ++p);
	switch (yych) {
	case '.':	goto yy38;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy43;
	default:	goto yy21;
	}
yy21:
	{ RETURNTOKEN( NUMBER ); }
yy22:
	++p;
	{ RETURNTOKEN( EQ ); }
yy24:
	++p;
	yych = *p;
yy25:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy24;
	default:	goto yy26;
	}
yy26:
	{ RETURNTOKEN( ID ); }
yy27:
	++p;
	{ RETURNTOKEN( LEFT_SQUARE ); }
yy29:
	++p;
	{ RETURNTOKEN( RIGHT_SQUARE ); }
yy31:
	yych = *++p;
	switch (yych) {
	case 'a':	goto yy44;
	default:	goto yy25;
	}
yy32:
	yych = *++p;
	switch (yych) {
	case 'r':	goto yy45;
	default:	goto yy25;
	}
yy33:
	++p;
yy34:
	{
    COUNTLINES;
    RETURNTOKEN( EOF );
  }
yy35:
	++p;
	{
    COUNTLINES;
    RETURNTOKEN( STRING );
  }
yy37:
	++p;
	yych = *p;
	switch (yych) {
	case '"':
	case '/':
	case '\\':
	case 'b':
	case 'f':
	case 'n':
	case 'r':
	case 't':	goto yy10;
	case 'u':	goto yy46;
	default:	goto yy2;
	}
yy38:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy41;
	default:	goto yy2;
	}
yy39:
	yyaccept = 0;
	YYMARKER = ++p;
	yych = *p;
yy40:
	switch (yych) {
	case '.':	goto yy38;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy39;
	default:	goto yy21;
	}
yy41:
	++p;
	yych = *p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy41;
	default:	goto yy21;
	}
yy43:
	yyaccept = 0;
	yych = *(YYMARKER = ++p);
	switch (yych) {
	case '.':	goto yy38;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy47;
	default:	goto yy21;
	}
yy44:
	yych = *++p;
	switch (yych) {
	case 'l':	goto yy48;
	default:	goto yy25;
	}
yy45:
	yych = *++p;
	switch (yych) {
	case 'u':	goto yy49;
	default:	goto yy25;
	}
yy46:
	++p;
	yych = *p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy50;
	default:	goto yy34;
	}
yy47:
	yyaccept = 0;
	yych = *(YYMARKER = ++p);
	switch (yych) {
	case '.':	goto yy38;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy51;
	default:	goto yy21;
	}
yy48:
	yych = *++p;
	switch (yych) {
	case 's':	goto yy52;
	default:	goto yy25;
	}
yy49:
	yych = *++p;
	switch (yych) {
	case 'e':	goto yy53;
	default:	goto yy25;
	}
yy50:
	++p;
	yych = *p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy55;
	default:	goto yy34;
	}
yy51:
	yyaccept = 0;
	yych = *(YYMARKER = ++p);
	switch (yych) {
	case '-':	goto yy56;
	default:	goto yy40;
	}
yy52:
	yych = *++p;
	switch (yych) {
	case 'e':	goto yy57;
	default:	goto yy25;
	}
yy53:
	++p;
	switch ((yych = *p)) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy24;
	default:	goto yy54;
	}
yy54:
	{ RETURNTOKEN( TRUE ); }
yy55:
	++p;
	yych = *p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy59;
	default:	goto yy34;
	}
yy56:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy60;
	default:	goto yy2;
	}
yy57:
	++p;
	switch ((yych = *p)) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '_':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy24;
	default:	goto yy58;
	}
yy58:
	{ RETURNTOKEN( FALSE ); }
yy59:
	yyaccept = 1;
	YYMARKER = ++p;
	yych = *p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy10;
	default:	goto yy34;
	}
yy60:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy61;
	default:	goto yy2;
	}
yy61:
	yych = *++p;
	switch (yych) {
	case '-':	goto yy62;
	default:	goto yy2;
	}
yy62:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy63;
	default:	goto yy2;
	}
yy63:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy64;
	default:	goto yy2;
	}
yy64:
	yych = *++p;
	switch (yych) {
	case 'T':	goto yy65;
	default:	goto yy2;
	}
yy65:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy66;
	default:	goto yy2;
	}
yy66:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy67;
	default:	goto yy2;
	}
yy67:
	yych = *++p;
	switch (yych) {
	case ':':	goto yy68;
	default:	goto yy2;
	}
yy68:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy69;
	default:	goto yy2;
	}
yy69:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy70;
	default:	goto yy2;
	}
yy70:
	yych = *++p;
	switch (yych) {
	case ':':	goto yy71;
	default:	goto yy2;
	}
yy71:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy72;
	default:	goto yy2;
	}
yy72:
	yych = *++p;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy73;
	default:	goto yy2;
	}
yy73:
	yych = *++p;
	switch (yych) {
	case 'Z':	goto yy74;
	default:	goto yy2;
	}
yy74:
	++p;
	{
    RETURNTOKEN( DATE );
  }
}

}
/* Driver template for the LEMON parser generator.
** The author disclaims copyright to this source code.
*/
/* First off, code is included that follows the "include" declaration
** in the input grammar file. */
#include <stdio.h>

#include <assert.h>
#include <stdlib.h>

typedef struct table_id_node {
  char *name;
  struct table_id_node *first;
  struct table_id_node *next;
} table_id_node;

char * _TOML_newstr( TOMLToken *token ) {
  if ( token->tokenStr ) {
    char *buffer = token->tokenStr;
    token->tokenStr = NULL;
    return buffer;
  }

  int size = token->end - token->start;
  char *buffer = malloc( size + 1 );
  strncpy( buffer, token->start, size );
  buffer[ size ] = 0;
  return buffer;
}

char * _TOML_getline( TOMLToken *token ) {
  char *endOfLine = strchr( token->lineStart, '\n' );
  if ( endOfLine == NULL ) {
    endOfLine = strchr( token->lineStart, 0 );
  }

  int size = endOfLine - token->lineStart;
  char *buffer = malloc( size + 1 );
  strncpy( buffer, token->lineStart, size );
  buffer[ size ] = 0;

  return buffer;
}

void _TOML_fillError(
  TOMLToken *token, TOMLParserState *state, int errorCode
) {
  state->errorCode = errorCode;

  TOMLError *error = state->errorObj;
  if ( error ) {
    error->code = errorCode;
    error->lineNo = token->line;
    error->line = _TOML_getline( state->token );

    int messageSize = strlen( TOMLErrorDescription[ errorCode ] );
    error->message = malloc( messageSize + 1 );
    strncpy( error->message, TOMLErrorDescription[ errorCode ], messageSize );
    error->message[ messageSize ] = 0;

    char *longMessage = malloc(
      strlen( error->line ) +
      strlen( error->message ) +
      (int) ( error->lineNo / 10 ) +
      20
    );
    sprintf(
      longMessage,
      "Error on line %d. %s: %s",
      error->lineNo,
      error->message,
      error->line
    );
    error->fullDescription = longMessage;
  }
}

void TOML_freeToken( TOMLToken *token ) {
  free( token->tokenStr );
  free( token );
}
/* Next is all token values, in a form suitable for use by makeheaders.
** This section will be null unless lemon is run with the -m switch.
*/
/*
** These constants (all generated automatically by the parser generator)
** specify the various kinds of tokens (terminals) that the parser
** understands.
**
** Each symbol here is a terminal symbol in the grammar.
*/
/* Make sure the INTERFACE macro is defined.
*/
#ifndef INTERFACE
# define INTERFACE 1
#endif
/* The next thing included is series of defines which control
** various aspects of the generated parser.
**    YYCODETYPE         is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 terminals
**                       and nonterminals.  "int" is used otherwise.
**    YYNOCODE           is a number of type YYCODETYPE which corresponds
**                       to no legal terminal or nonterminal number.  This
**                       number is used to fill in empty slots of the hash
**                       table.
**    YYFALLBACK         If defined, this indicates that one or more tokens
**                       have fall-back values which should be used if the
**                       original value of the token will not parse.
**    YYACTIONTYPE       is the data type used for storing terminal
**                       and nonterminal numbers.  "unsigned char" is
**                       used if there are fewer than 250 rules and
**                       states combined.  "int" is used otherwise.
**    TOMLParserTOKENTYPE     is the data type used for minor tokens given
**                       directly to the parser from the tokenizer.
**    YYMINORTYPE        is the data type used for all minor tokens.
**                       This is typically a union of many types, one of
**                       which is TOMLParserTOKENTYPE.  The entry in the union
**                       for base tokens is called "yy0".
**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If
**                       zero the stack is dynamically sized using realloc()
**    TOMLParserARG_SDECL     A static variable declaration for the %extra_argument
**    TOMLParserARG_PDECL     A parameter declaration for the %extra_argument
**    TOMLParserARG_STORE     Code to store %extra_argument into yypParser
**    TOMLParserARG_FETCH     Code to extract %extra_argument from yypParser
**    YYNSTATE           the combined number of states.
**    YYNRULE            the number of rules in the grammar
**    YYERRORSYMBOL      is the code number of the error symbol.  If not
**                       defined, then do no error processing.
*/
#define YYCODETYPE unsigned char
#define YYNOCODE 34
#define YYACTIONTYPE unsigned char
#define TOMLParserTOKENTYPE void*
typedef union {
  int yyinit;
  TOMLParserTOKENTYPE yy0;
  TOMLBoolean * yy3;
  TOMLDate * yy4;
  TOMLNumber * yy8;
  TOMLBasic * yy13;
  TOMLArray * yy50;
  table_id_node * yy62;
  int yy67;
} YYMINORTYPE;
#ifndef YYSTACKDEPTH
#define YYSTACKDEPTH 100
#endif
#define TOMLParserARG_SDECL  TOMLParserState *state ;
#define TOMLParserARG_PDECL , TOMLParserState *state
#define TOMLParserARG_FETCH  TOMLParserState *state  = yypParser->state
#define TOMLParserARG_STORE yypParser->state  = state
#define YYNSTATE 46
#define YYNRULE 35
#define YYERRORSYMBOL 14
#define YYERRSYMDT yy67
#define YY_NO_ACTION      (YYNSTATE+YYNRULE+2)
#define YY_ACCEPT_ACTION  (YYNSTATE+YYNRULE+1)
#define YY_ERROR_ACTION   (YYNSTATE+YYNRULE)

/* The yyzerominor constant is used to initialize instances of
** YYMINORTYPE objects to zero. */
static const YYMINORTYPE yyzerominor = { 0 };

/* Define the yytestcase() macro to be a no-op if is not already defined
** otherwise.
**
** Applications can choose to define yytestcase() in the %include section
** to a macro that can assist in verifying code coverage.  For production
** code the yytestcase() macro should be turned off.  But it is useful
** for testing.
*/
#ifndef yytestcase
# define yytestcase(X)
#endif


/* Next are the tables used to determine what action to take based on the
** current state and lookahead token.  These tables are used to implement
** functions that take a state number and lookahead value and return an
** action integer.
**
** Suppose the action integer is N.  Then the action is determined as
** follows
**
**   0 <= N < YYNSTATE                  Shift N.  That is, push the lookahead
**                                      token onto the stack and goto state N.
**
**   YYNSTATE <= N < YYNSTATE+YYNRULE   Reduce by rule N-YYNSTATE.
**
**   N == YYNSTATE+YYNRULE              A syntax error has occurred.
**
**   N == YYNSTATE+YYNRULE+1            The parser accepts its input.
**
**   N == YYNSTATE+YYNRULE+2            No such action.  Denotes unused
**                                      slots in the yy_action[] table.
**
** The action table is constructed as a single large table named yy_action[].
** Given state S and lookahead X, the action is computed as
**
**      yy_action[ yy_shift_ofst[S] + X ]
**
** If the index value yy_shift_ofst[S]+X is out of range or if the value
** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]
** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table
** and that yy_default[S] should be used instead.
**
** The formula above is for computing the action when the lookahead is
** a terminal symbol.  If the lookahead is a non-terminal (as occurs after
** a reduce action) then the yy_reduce_ofst[] array is used in place of
** the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of
** YY_SHIFT_USE_DFLT.
**
** The following are the tables generated in this section:
**
**  yy_action[]        A single table containing all actions.
**  yy_lookahead[]     A table containing the lookahead for each entry in
**                     yy_action.  Used to detect hash collisions.
**  yy_shift_ofst[]    For each state, the offset into yy_action for
**                     shifting terminals.
**  yy_reduce_ofst[]   For each state, the offset into yy_action for
**                     shifting non-terminals after a reduce.
**  yy_default[]       Default action for each state.
*/
static const YYACTIONTYPE yy_action[] = {
 /*     0 */    42,   25,   26,   27,   28,   29,   15,    8,   82,    4,
 /*    10 */    31,   33,   23,   22,   44,   10,    7,    1,   43,   11,
 /*    20 */    17,   18,    9,   36,   37,   38,   39,   40,   24,   25,
 /*    30 */    26,   27,   28,   29,    1,   46,   32,   20,   10,    9,
 /*    40 */    36,   37,   38,   39,   40,   16,   45,   21,   35,   25,
 /*    50 */    26,   27,   28,   29,   14,   12,   17,   10,   34,   33,
 /*    60 */    23,   22,    2,   10,    7,    6,   13,   30,    5,   45,
 /*    70 */    30,    5,   45,   83,    3,   45,   19,   41,
};
static const YYCODETYPE yy_lookahead[] = {
 /*     0 */    24,   25,   26,   27,   28,   29,   30,   31,   15,   16,
 /*    10 */    17,   18,   19,   20,   14,    1,   23,    3,   14,   22,
 /*    20 */    23,    4,    5,    9,   10,   11,   12,   13,   24,   25,
 /*    30 */    26,   27,   28,   29,    3,    0,    4,   14,    1,    5,
 /*    40 */     9,   10,   11,   12,   13,   23,    7,   14,   24,   25,
 /*    50 */    26,   27,   28,   29,   21,   22,   23,    1,   17,   18,
 /*    60 */    19,   20,    6,    1,   23,    3,    1,    2,    3,    7,
 /*    70 */     2,    3,    7,   33,   32,    7,    4,    8,
};
#define YY_SHIFT_USE_DFLT (-1)
#define YY_SHIFT_MAX 15
static const signed char yy_shift_ofst[] = {
 /*     0 */    68,   31,   14,   31,   65,   62,   39,   56,   69,   39,
 /*    10 */    37,   17,   34,   35,   72,   32,
};
#define YY_REDUCE_USE_DFLT (-25)
#define YY_REDUCE_MAX 10
static const signed char yy_reduce_ofst[] = {
 /*     0 */    -7,  -24,    4,   24,   41,   33,   -3,    0,   42,   22,
 /*    10 */    23,
};
static const YYACTIONTYPE yy_default[] = {
 /*     0 */    81,   67,   81,   69,   81,   81,   81,   81,   66,   81,
 /*    10 */    81,   81,   55,   81,   81,   81,   56,   57,   54,   53,
 /*    20 */    77,   78,   52,   51,   58,   60,   61,   62,   63,   64,
 /*    30 */    50,   47,   65,   49,   48,   68,   72,   73,   74,   75,
 /*    40 */    76,   71,   70,   79,   80,   59,
};
#define YY_SZ_ACTTAB (int)(sizeof(yy_action)/sizeof(yy_action[0]))

/* The next table maps tokens into fallback tokens.  If a construct
** like the following:
**
**      %fallback ID X Y Z.
**
** appears in the grammar, then ID becomes a fallback token for X, Y,
** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser
** but it does not parse, the type of the token is changed to ID and
** the parse is retried before an error is thrown.
*/
#ifdef YYFALLBACK
static const YYCODETYPE yyFallback[] = {
};
#endif /* YYFALLBACK */

/* The following structure represents a single element of the
** parser's stack.  Information stored includes:
**
**   +  The state number for the parser at this level of the stack.
**
**   +  The value of the token stored at this level of the stack.
**      (In other words, the "major" token.)
**
**   +  The semantic value stored at this level of the stack.  This is
**      the information used by the action routines in the grammar.
**      It is sometimes called the "minor" token.
*/
struct yyStackEntry {
  YYACTIONTYPE stateno;  /* The state-number */
  YYCODETYPE major;      /* The major token value.  This is the code
                         ** number for the token at this stack level */
  YYMINORTYPE minor;     /* The user-supplied minor token value.  This
                         ** is the value of the token  */
};
typedef struct yyStackEntry yyStackEntry;

/* The state of the parser is completely contained in an instance of
** the following structure */
struct yyParser {
  int yyidx;                    /* Index of top element in stack */
#ifdef YYTRACKMAXSTACKDEPTH
  int yyidxMax;                 /* Maximum value of yyidx */
#endif
  int yyerrcnt;                 /* Shifts left before out of the error */
  TOMLParserARG_SDECL                /* A place to hold %extra_argument */
#if YYSTACKDEPTH<=0
  int yystksz;                  /* Current side of the stack */
  yyStackEntry *yystack;        /* The parser's stack */
#else
  yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */
#endif
};
typedef struct yyParser yyParser;

#ifndef NDEBUG
#include <stdio.h>
static FILE *yyTraceFILE = 0;
static char *yyTracePrompt = 0;
#endif /* NDEBUG */

#ifndef NDEBUG
/*
** Turn parser tracing on by giving a stream to which to write the trace
** and a prompt to preface each trace message.  Tracing is turned off
** by making either argument NULL
**
** Inputs:
** <ul>
** <li> A FILE* to which trace output should be written.
**      If NULL, then tracing is turned off.
** <li> A prefix string written at the beginning of every
**      line of trace output.  If NULL, then tracing is
**      turned off.
** </ul>
**
** Outputs:
** None.
*/
void TOMLParserTrace(FILE *TraceFILE, char *zTracePrompt){
  yyTraceFILE = TraceFILE;
  yyTracePrompt = zTracePrompt;
  if( yyTraceFILE==0 ) yyTracePrompt = 0;
  else if( yyTracePrompt==0 ) yyTraceFILE = 0;
}
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing shifts, the names of all terminals and nonterminals
** are required.  The following table supplies these names */
static const char *const yyTokenName[] = {
  "$",             "EOF",           "COMMENT",       "LEFT_SQUARE",
  "RIGHT_SQUARE",  "ID_DOT",        "EQ",            "ID",
  "COMMA",         "STRING",        "NUMBER",        "TRUE",
  "FALSE",         "DATE",          "error",         "file",
  "line",          "line_and_comment",  "line_content",  "table_header",
  "entry",         "table_header_2",  "table_id",      "id",
  "value",         "array",         "string",        "number",
  "boolean",       "date",          "members",       "value_members",
  "comma",
};
#endif /* NDEBUG */

#ifndef NDEBUG
/* For tracing reduce actions, the names of all rules are required.
*/
static const char *const yyRuleName[] = {
 /*   0 */ "file ::= line EOF",
 /*   1 */ "line ::= line_and_comment",
 /*   2 */ "line ::= line line_and_comment",
 /*   3 */ "line_and_comment ::= line_content",
 /*   4 */ "line_and_comment ::= COMMENT",
 /*   5 */ "line_content ::= table_header",
 /*   6 */ "line_content ::= entry",
 /*   7 */ "table_header ::= LEFT_SQUARE table_header_2 RIGHT_SQUARE",
 /*   8 */ "table_header_2 ::= LEFT_SQUARE table_id RIGHT_SQUARE",
 /*   9 */ "table_header_2 ::= table_id",
 /*  10 */ "table_id ::= table_id ID_DOT id",
 /*  11 */ "table_id ::= id",
 /*  12 */ "entry ::= id EQ value",
 /*  13 */ "id ::= ID",
 /*  14 */ "value ::= array",
 /*  15 */ "value ::= string",
 /*  16 */ "value ::= number",
 /*  17 */ "value ::= boolean",
 /*  18 */ "value ::= date",
 /*  19 */ "array ::= LEFT_SQUARE members RIGHT_SQUARE",
 /*  20 */ "members ::= value_members",
 /*  21 */ "members ::=",
 /*  22 */ "value_members ::= value_members comma value",
 /*  23 */ "value_members ::= value_members comma",
 /*  24 */ "value_members ::= value",
 /*  25 */ "comma ::= COMMA",
 /*  26 */ "string ::= STRING",
 /*  27 */ "number ::= NUMBER",
 /*  28 */ "boolean ::= TRUE",
 /*  29 */ "boolean ::= FALSE",
 /*  30 */ "date ::= DATE",
 /*  31 */ "error ::= EOF error",
 /*  32 */ "table_header ::= LEFT_SQUARE error",
 /*  33 */ "entry ::= id EQ error",
 /*  34 */ "entry ::= id error",
};
#endif /* NDEBUG */


#if YYSTACKDEPTH<=0
/*
** Try to increase the size of the parser stack.
*/
static void yyGrowStack(yyParser *p){
  int newSize;
  yyStackEntry *pNew;

  newSize = p->yystksz*2 + 100;
  pNew = realloc(p->yystack, newSize*sizeof(pNew[0]));
  if( pNew ){
    p->yystack = pNew;
    p->yystksz = newSize;
#ifndef NDEBUG
    if( yyTraceFILE ){
      fprintf(yyTraceFILE,"%sStack grows to %d entries!\n",
              yyTracePrompt, p->yystksz);
    }
#endif
  }
}
#endif

/*
** This function allocates a new parser.
** The only argument is a pointer to a function which works like
** malloc.
**
** Inputs:
** A pointer to the function used to allocate memory.
**
** Outputs:
** A pointer to a parser.  This pointer is used in subsequent calls
** to TOMLParser and TOMLParserFree.
*/
void *TOMLParserAlloc(void *(*mallocProc)(size_t)){
  yyParser *pParser;
  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );
  if( pParser ){
    pParser->yyidx = -1;
#ifdef YYTRACKMAXSTACKDEPTH
    pParser->yyidxMax = 0;
#endif
#if YYSTACKDEPTH<=0
    pParser->yystack = NULL;
    pParser->yystksz = 0;
    yyGrowStack(pParser);
#endif
  }
  return pParser;
}

/* The following function deletes the value associated with a
** symbol.  The symbol can be either a terminal or nonterminal.
** "yymajor" is the symbol code, and "yypminor" is a pointer to
** the value.
*/
static void yy_destructor(
  yyParser *yypParser,    /* The parser */
  YYCODETYPE yymajor,     /* Type code for object to destroy */
  YYMINORTYPE *yypminor   /* The object to be destroyed */
){
  TOMLParserARG_FETCH;
  (void)state;
  switch( yymajor ){
    /* Here is inserted the actions which take place when a
    ** terminal or non-terminal is destroyed.  This can happen
    ** when the symbol is popped from the stack during a
    ** reduce or during error processing or when a parser is
    ** being destroyed before it is finished parsing.
    **
    ** Note: during a reduce, the only symbols destroyed are those
    ** which appear on the RHS of the rule, but which are not used
    ** inside the C code.
    */
      /* TERMINAL Destructor */
    case 1: /* EOF */
    case 2: /* COMMENT */
    case 3: /* LEFT_SQUARE */
    case 4: /* RIGHT_SQUARE */
    case 5: /* ID_DOT */
    case 6: /* EQ */
    case 7: /* ID */
    case 8: /* COMMA */
    case 9: /* STRING */
    case 10: /* NUMBER */
    case 11: /* TRUE */
    case 12: /* FALSE */
    case 13: /* DATE */
{
 TOML_freeToken((yypminor->yy0));
}
      break;
    default:  break;   /* If no destructor action specified: do nothing */
  }
}

/*
** Pop the parser's stack once.
**
** If there is a destructor routine associated with the token which
** is popped from the stack, then call it.
**
** Return the major token number for the symbol popped.
*/
static int yy_pop_parser_stack(yyParser *pParser){
  YYCODETYPE yymajor;
  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];

  if( pParser->yyidx<0 ) return 0;
#ifndef NDEBUG
  if( yyTraceFILE && pParser->yyidx>=0 ){
    fprintf(yyTraceFILE,"%sPopping %s\n",
      yyTracePrompt,
      yyTokenName[yytos->major]);
  }
#endif
  yymajor = yytos->major;
  yy_destructor(pParser, yymajor, &yytos->minor);
  pParser->yyidx--;
  return yymajor;
}

/*
** Deallocate and destroy a parser.  Destructors are all called for
** all stack elements before shutting the parser down.
**
** Inputs:
** <ul>
** <li>  A pointer to the parser.  This should be a pointer
**       obtained from TOMLParserAlloc.
** <li>  A pointer to a function used to reclaim memory obtained
**       from malloc.
** </ul>
*/
void TOMLParserFree(
  void *p,                    /* The parser to be deleted */
  void (*freeProc)(void*)     /* Function used to reclaim memory */
){
  yyParser *pParser = (yyParser*)p;
  if( pParser==0 ) return;
  while( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser);
#if YYSTACKDEPTH<=0
  free(pParser->yystack);
#endif
  (*freeProc)((void*)pParser);
}

/*
** Return the peak depth of the stack for a parser.
*/
#ifdef YYTRACKMAXSTACKDEPTH
int TOMLParserStackPeak(void *p){
  yyParser *pParser = (yyParser*)p;
  return pParser->yyidxMax;
}
#endif

/*
** Find the appropriate action for a parser given the terminal
** look-ahead token iLookAhead.
**
** If the look-ahead token is YYNOCODE, then check to see if the action is
** independent of the look-ahead.  If it is, return the action, otherwise
** return YY_NO_ACTION.
*/
static int yy_find_shift_action(
  yyParser *pParser,        /* The parser */
  YYCODETYPE iLookAhead     /* The look-ahead token */
){
  int i;
  int stateno = pParser->yystack[pParser->yyidx].stateno;

  if( stateno>YY_SHIFT_MAX || (i = yy_shift_ofst[stateno])==YY_SHIFT_USE_DFLT ){
    return yy_default[stateno];
  }
  assert( iLookAhead!=YYNOCODE );
  i += iLookAhead;
  if( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){
    if( iLookAhead>0 ){
#ifdef YYFALLBACK
      YYCODETYPE iFallback;            /* Fallback token */
      if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])
             && (iFallback = yyFallback[iLookAhead])!=0 ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE, "%sFALLBACK %s => %s\n",
             yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);
        }
#endif
        return yy_find_shift_action(pParser, iFallback);
      }
#endif
#ifdef YYWILDCARD
      {
        int j = i - iLookAhead + YYWILDCARD;
        if( j>=0 && j<YY_SZ_ACTTAB && yy_lookahead[j]==YYWILDCARD ){
#ifndef NDEBUG
          if( yyTraceFILE ){
            fprintf(yyTraceFILE, "%sWILDCARD %s => %s\n",
               yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[YYWILDCARD]);
          }
#endif /* NDEBUG */
          return yy_action[j];
        }
      }
#endif /* YYWILDCARD */
    }
    return yy_default[stateno];
  }else{
    return yy_action[i];
  }
}

/*
** Find the appropriate action for a parser given the non-terminal
** look-ahead token iLookAhead.
**
** If the look-ahead token is YYNOCODE, then check to see if the action is
** independent of the look-ahead.  If it is, return the action, otherwise
** return YY_NO_ACTION.
*/
static int yy_find_reduce_action(
  int stateno,              /* Current state number */
  YYCODETYPE iLookAhead     /* The look-ahead token */
){
  int i;
#ifdef YYERRORSYMBOL
  if( stateno>YY_REDUCE_MAX ){
    return yy_default[stateno];
  }
#else
  assert( stateno<=YY_REDUCE_MAX );
#endif
  i = yy_reduce_ofst[stateno];
  assert( i!=YY_REDUCE_USE_DFLT );
  assert( iLookAhead!=YYNOCODE );
  i += iLookAhead;
#ifdef YYERRORSYMBOL
  if( i<0 || i>=YY_SZ_ACTTAB || yy_lookahead[i]!=iLookAhead ){
    return yy_default[stateno];
  }
#else
  assert( i>=0 && i<YY_SZ_ACTTAB );
  assert( yy_lookahead[i]==iLookAhead );
#endif
  return yy_action[i];
}

/*
** The following routine is called if the stack overflows.
*/
static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){
   TOMLParserARG_FETCH;
   yypParser->yyidx--;
#ifndef NDEBUG
   if( yyTraceFILE ){
     fprintf(yyTraceFILE,"%sStack Overflow!\n",yyTracePrompt);
   }
#endif
   while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
   /* Here code is inserted which will execute if the parser
   ** stack every overflows */
   TOMLParserARG_STORE; /* Suppress warning about unused %extra_argument var */
}

/*
** Perform a shift action.
*/
static void yy_shift(
  yyParser *yypParser,          /* The parser to be shifted */
  int yyNewState,               /* The new state to shift in */
  int yyMajor,                  /* The major token to shift in */
  YYMINORTYPE *yypMinor         /* Pointer to the minor token to shift in */
){
  yyStackEntry *yytos;
  yypParser->yyidx++;
#ifdef YYTRACKMAXSTACKDEPTH
  if( yypParser->yyidx>yypParser->yyidxMax ){
    yypParser->yyidxMax = yypParser->yyidx;
  }
#endif
#if YYSTACKDEPTH>0
  if( yypParser->yyidx>=YYSTACKDEPTH ){
    yyStackOverflow(yypParser, yypMinor);
    return;
  }
#else
  if( yypParser->yyidx>=yypParser->yystksz ){
    yyGrowStack(yypParser);
    if( yypParser->yyidx>=yypParser->yystksz ){
      yyStackOverflow(yypParser, yypMinor);
      return;
    }
  }
#endif
  yytos = &yypParser->yystack[yypParser->yyidx];
  yytos->stateno = (YYACTIONTYPE)yyNewState;
  yytos->major = (YYCODETYPE)yyMajor;
  yytos->minor = *yypMinor;
#ifndef NDEBUG
  if( yyTraceFILE && yypParser->yyidx>0 ){
    int i;
    fprintf(yyTraceFILE,"%sShift %d\n",yyTracePrompt,yyNewState);
    fprintf(yyTraceFILE,"%sStack:",yyTracePrompt);
    for(i=1; i<=yypParser->yyidx; i++)
      fprintf(yyTraceFILE," %s",yyTokenName[yypParser->yystack[i].major]);
    fprintf(yyTraceFILE,"\n");
  }
#endif
}

/* The following table contains information about every rule that
** is used during the reduce.
*/
static const struct {
  YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */
  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */
} yyRuleInfo[] = {
  { 15, 2 },
  { 16, 1 },
  { 16, 2 },
  { 17, 1 },
  { 17, 1 },
  { 18, 1 },
  { 18, 1 },
  { 19, 3 },
  { 21, 3 },
  { 21, 1 },
  { 22, 3 },
  { 22, 1 },
  { 20, 3 },
  { 23, 1 },
  { 24, 1 },
  { 24, 1 },
  { 24, 1 },
  { 24, 1 },
  { 24, 1 },
  { 25, 3 },
  { 30, 1 },
  { 30, 0 },
  { 31, 3 },
  { 31, 2 },
  { 31, 1 },
  { 32, 1 },
  { 26, 1 },
  { 27, 1 },
  { 28, 1 },
  { 28, 1 },
  { 29, 1 },
  { 14, 2 },
  { 19, 2 },
  { 20, 3 },
  { 20, 2 },
};

static void yy_accept(yyParser*);  /* Forward Declaration */

/*
** Perform a reduce action and the shift that must immediately
** follow the reduce.
*/
static void yy_reduce(
  yyParser *yypParser,         /* The parser */
  int yyruleno                 /* Number of the rule by which to reduce */
){
  int yygoto;                     /* The next state */
  int yyact;                      /* The next action */
  YYMINORTYPE yygotominor;        /* The LHS of the rule reduced */
  yyStackEntry *yymsp;            /* The top of the parser's stack */
  int yysize;                     /* Amount to pop the stack */
  TOMLParserARG_FETCH;
  yymsp = &yypParser->yystack[yypParser->yyidx];
#ifndef NDEBUG
  if( yyTraceFILE && yyruleno>=0
        && yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){
    fprintf(yyTraceFILE, "%sReduce [%s].\n", yyTracePrompt,
      yyRuleName[yyruleno]);
  }
#endif /* NDEBUG */

  /* Silence complaints from purify about yygotominor being uninitialized
  ** in some cases when it is copied into the stack after the following
  ** switch.  yygotominor is uninitialized when a rule reduces that does
  ** not set the value of its left-hand side nonterminal.  Leaving the
  ** value of the nonterminal uninitialized is utterly harmless as long
  ** as the value is never used.  So really the only thing this code
  ** accomplishes is to quieten purify.
  **
  ** 2007-01-16:  The wireshark project (www.wireshark.org) reports that
  ** without this code, their parser segfaults.  I'm not sure what there
  ** parser is doing to make this happen.  This is the second bug report
  ** from wireshark this week.  Clearly they are stressing Lemon in ways
  ** that it has not been previously stressed...  (SQLite ticket #2172)
  */
  /*memset(&yygotominor, 0, sizeof(yygotominor));*/
  yygotominor = yyzerominor;


  switch( yyruleno ){
  /* Beginning here are the reduction cases.  A typical example
  ** follows:
  **   case 0:
  **  #line <lineno> <grammarfile>
  **     { ... }           // User supplied code
  **  #line <lineno> <thisfile>
  **     break;
  */
      case 0: /* file ::= line EOF */
{
  yy_destructor(yypParser,1,&yymsp[0].minor);
}
        break;
      case 4: /* line_and_comment ::= COMMENT */
{
  yy_destructor(yypParser,2,&yymsp[0].minor);
}
        break;
      case 7: /* table_header ::= LEFT_SQUARE table_header_2 RIGHT_SQUARE */
{
  yy_destructor(yypParser,3,&yymsp[-2].minor);
  yy_destructor(yypParser,4,&yymsp[0].minor);
}
        break;
      case 8: /* table_header_2 ::= LEFT_SQUARE table_id RIGHT_SQUARE */
{
  table_id_node *first = yymsp[-1].minor.yy62->first;
  table_id_node *node = first;
  table_id_node *next = node->next;
  TOMLTable *table = state->rootTable;

  for ( ; node; node = next ) {
    TOMLTable *tmpTable = TOMLTable_getKey( table, node->name );
    TOMLBasic *tmpBasic = (TOMLBasic *) tmpTable;

    if ( tmpTable && tmpBasic->type == TOML_ARRAY && node->next ) {
      TOMLArray *tmpArray = (TOMLArray *) tmpBasic;
      tmpTable = TOMLArray_getIndex( tmpArray, tmpArray->size - 1 );
    }

    if ( !tmpTable ) {
      TOMLRef nextValue;
      if ( node->next ) {
        nextValue = TOML_allocTable( NULL, NULL );
      } else {
        nextValue = TOML_allocArray( TOML_TABLE, NULL );
      }
      TOMLTable_setKey( table, node->name, nextValue );
      tmpTable = nextValue;
    }
    table = tmpTable;
    next = node->next;
    free( node->name );
    free( node );
  }

  TOMLArray *array = (TOMLArray *) table;
  table = TOML_allocTable( NULL, NULL );
  TOMLArray_append( array, table );

  state->currentTable = table;
  yy_destructor(yypParser,3,&yymsp[-2].minor);
  yy_destructor(yypParser,4,&yymsp[0].minor);
}
        break;
      case 9: /* table_header_2 ::= table_id */
{
  table_id_node *first = yymsp[0].minor.yy62->first;
  table_id_node *node = first;
  table_id_node *next = node->next;
  TOMLTable *table = state->rootTable;

  for ( ; node; node = next ) {
    TOMLTable *tmpTable = TOMLTable_getKey( table, node->name );
    TOMLBasic *tmpBasic = (TOMLBasic *) tmpTable;

    if ( tmpTable && tmpBasic->type == TOML_ARRAY ) {
      TOMLArray *tmpArray = (TOMLArray *) tmpBasic;
      tmpTable = TOMLArray_getIndex( tmpArray, tmpArray->size - 1 );
    }

    if ( tmpTable && node->next == NULL ) {
      _TOML_fillError( state->token, state, TOML_ERROR_TABLE_DEFINED );
    } else if ( !tmpTable ) {
      tmpTable = TOML_allocTable( NULL, NULL );
      TOMLTable_setKey( table, node->name, tmpTable );
    }
    table = tmpTable;
    next = node->next;
    free( node->name );
    free( node );
  }

  state->currentTable = table;
}
        break;
      case 10: /* table_id ::= table_id ID_DOT id */
{
  table_id_node *node = malloc( sizeof(table_id_node) );
  node->name = yymsp[0].minor.yy0;
  node->first = yymsp[-2].minor.yy62->first;
  node->next = NULL;
  yymsp[-2].minor.yy62->next = node;
  yygotominor.yy62 = node;
  yy_destructor(yypParser,5,&yymsp[-1].minor);
}
        break;
      case 11: /* table_id ::= id */
{
  table_id_node *node = malloc( sizeof(table_id_node) );
  node->name = yymsp[0].minor.yy0;
  node->first = node;
  node->next = NULL;
  yygotominor.yy62 = node;
}
        break;
      case 12: /* entry ::= id EQ value */
{
  if ( yymsp[-2].minor.yy0 != NULL || yymsp[0].minor.yy13 != NULL ) {
    TOMLRef oldValue = TOMLTable_getKey( state->currentTable, yymsp[-2].minor.yy0 );
    if ( oldValue != NULL ) {
      _TOML_fillError( state->token, state, TOML_ERROR_ENTRY_DEFINED );
    } else {
      TOMLTable_setKey( state->currentTable, yymsp[-2].minor.yy0, yymsp[0].minor.yy13 );
    }
  }
  free( yymsp[-2].minor.yy0 );
  yy_destructor(yypParser,6,&yymsp[-1].minor);
}
        break;
      case 13: /* id ::= ID */
{
  yygotominor.yy0 = _TOML_newstr( yymsp[0].minor.yy0 );
}
        break;
      case 14: /* value ::= array */
      case 15: /* value ::= string */ yytestcase(yyruleno==15);
{ yygotominor.yy13 = (TOMLBasic *) yymsp[0].minor.yy0; }
        break;
      case 16: /* value ::= number */
{ yygotominor.yy13 = (TOMLBasic *) yymsp[0].minor.yy8; }
        break;
      case 17: /* value ::= boolean */
{ yygotominor.yy13 = (TOMLBasic *) yymsp[0].minor.yy3; }
        break;
      case 18: /* value ::= date */
{ yygotominor.yy13 = (TOMLBasic *) yymsp[0].minor.yy4; }
        break;
      case 19: /* array ::= LEFT_SQUARE members RIGHT_SQUARE */
{
  yygotominor.yy0 = yymsp[-1].minor.yy0;
  yy_destructor(yypParser,3,&yymsp[-2].minor);
  yy_destructor(yypParser,4,&yymsp[0].minor);
}
        break;
      case 20: /* members ::= value_members */
{ yygotominor.yy0 = yymsp[0].minor.yy50; }
        break;
      case 21: /* members ::= */
{ yygotominor.yy0 = TOML_allocArray( TOML_NOTYPE, NULL ); }
        break;
      case 22: /* value_members ::= value_members comma value */
{
  if ( yymsp[-2].minor.yy50->memberType != yymsp[0].minor.yy13->type ) {
    _TOML_fillError( state->token, state, TOML_ERROR_ARRAY_MEMBER_MISMATCH );
  }
  yygotominor.yy50 = yymsp[-2].minor.yy50;
  TOMLArray_append( yygotominor.yy50, yymsp[0].minor.yy13 );
}
        break;
      case 23: /* value_members ::= value_members comma */
{
  yygotominor.yy50 = yymsp[-1].minor.yy50;
}
        break;
      case 24: /* value_members ::= value */
{
  yygotominor.yy50 = TOML_allocArray( yymsp[0].minor.yy13->type, yymsp[0].minor.yy13, NULL );
}
        break;
      case 25: /* comma ::= COMMA */
{
  yy_destructor(yypParser,8,&yymsp[0].minor);
}
        break;
      case 26: /* string ::= STRING */
{
  TOMLToken *token = yymsp[0].minor.yy0;
  int size = token->end - token->start;

  char *tmp = _TOML_newstr( token );

  char *dest = malloc( size + 1 );
  strncpy( dest, tmp, size );
  dest[ size ] = 0;

  char *tmpCursor = tmp;
  char *destCursor = dest;

  // replace \\b with \b (U+0008)
  // replace \\t with \t (U+0009)
  // replace \\n with \n (U+000A)
  // replace \\f with \f (U+000C)
  // replace \\r with \r (U+000D)
  // replace \\\" with " (U+0022)
  // replace \/ with / (U+002F)
  // replace \\ with \ (U+005C)
  // replace \\uxxxx with encoded character
  while ( tmpCursor != NULL ) {
    char *next = strchr( tmpCursor, '\\' );
    if ( next && next[1] ) {
      char *nextDest = destCursor + ( next - tmpCursor );
      #define REPLACE( match, value ) \
      if ( next[1] == match ) { \
        *nextDest = value; \
      }
      REPLACE( 'b', '\b' )
      else REPLACE( 't', '\t' )
      else REPLACE( 'f', '\f' )
      else REPLACE( 'n', '\n' )
      else REPLACE( 'r', '\r' )
      else REPLACE( '"', '"' )
      else REPLACE( '/', '/' )
      else REPLACE( '\\', '\\' )
      #undef REPLACE
      else if ( next[1] == 'u' ) {
        int num = 0;
        sscanf( next + 2, "%04x", &num );
        int chsize = 0;

        // Number is in normal ascii range.
        if ( num < 0x80 ) {
          nextDest[0] = num; // Up to 0x7f
          chsize = 1;
        // Split the value into 2 or 3 chars as utf8.
        } else if ( num < 0x800 ) {
          nextDest[0] = 0xc0 | ( ( num >> 6 ) & 0x1f );
          nextDest[1] = 0x80 | ( num & 0x3f );
          chsize = 2;
        } else {
          nextDest[0] = 0xe0 | ( ( num >> 12 ) & 0x0f );
          nextDest[1] = 0x80 | ( ( num >> 6 ) & 0x3f );
          nextDest[2] = 0x80 | ( num & 0x3f );
          chsize = 3;
        }

        next += 4;
        nextDest += chsize - 1;
        size -= 5 - chsize;
      }

      size--;
      strcpy( nextDest + 1, next + 2 );
      tmpCursor = next + 2;
      destCursor = nextDest + 1;
    } else {
      tmpCursor = next;
    }
  }

  yygotominor.yy0 = TOML_allocStringN( dest + 1, size - 2 );

  free( dest );
  free( tmp );
}
        break;
      case 27: /* number ::= NUMBER */
{
  char *tmp = _TOML_newstr( yymsp[0].minor.yy0 );

  if ( strchr( tmp, '.' ) != NULL ) {
    yygotominor.yy8 = TOML_allocDouble( atof( tmp ) );
  } else {
    yygotominor.yy8 = TOML_allocInt( atoi( tmp ) );
  }

  free( tmp );
}
        break;
      case 28: /* boolean ::= TRUE */
{
  yygotominor.yy3 = TOML_allocBoolean( 1 );
  yy_destructor(yypParser,11,&yymsp[0].minor);
}
        break;
      case 29: /* boolean ::= FALSE */
{
  yygotominor.yy3 = TOML_allocBoolean( 0 );
  yy_destructor(yypParser,12,&yymsp[0].minor);
}
        break;
      case 30: /* date ::= DATE */
{
  int year;
  int month;
  int day;
  int hour;
  int minute;
  int second;
  sscanf(
    ((TOMLToken *) yymsp[0].minor.yy0)->tokenStr,
    "%d-%d-%dT%d:%d:%dZ",
    &year, &month, &day, &hour, &minute, &second
  );
  yygotominor.yy4 = TOML_allocDate( year, month, day, hour, minute, second );
}
        break;
      case 31: /* error ::= EOF error */
{ yygotominor.yy67 = yymsp[0].minor.yy67;   yy_destructor(yypParser,1,&yymsp[-1].minor);
}
        break;
      case 32: /* table_header ::= LEFT_SQUARE error */
{
  _TOML_fillError( yymsp[-1].minor.yy0, state, TOML_ERROR_INVALID_HEADER );
}
        break;
      case 33: /* entry ::= id EQ error */
{
  _TOML_fillError( state->token, state, TOML_ERROR_NO_VALUE );
  free( yymsp[-2].minor.yy0 );
  yy_destructor(yypParser,6,&yymsp[-1].minor);
}
        break;
      case 34: /* entry ::= id error */
{
  _TOML_fillError( state->token, state, TOML_ERROR_NO_EQ );
  free( yymsp[-1].minor.yy0 );
}
        break;
      default:
      /* (1) line ::= line_and_comment */ yytestcase(yyruleno==1);
      /* (2) line ::= line line_and_comment */ yytestcase(yyruleno==2);
      /* (3) line_and_comment ::= line_content */ yytestcase(yyruleno==3);
      /* (5) line_content ::= table_header */ yytestcase(yyruleno==5);
      /* (6) line_content ::= entry */ yytestcase(yyruleno==6);
        break;
  };
  yygoto = yyRuleInfo[yyruleno].lhs;
  yysize = yyRuleInfo[yyruleno].nrhs;
  yypParser->yyidx -= yysize;
  yyact = yy_find_reduce_action(yymsp[-yysize].stateno,(YYCODETYPE)yygoto);
  if( yyact < YYNSTATE ){
#ifdef NDEBUG
    /* If we are not debugging and the reduce action popped at least
    ** one element off the stack, then we can push the new element back
    ** onto the stack here, and skip the stack overflow test in yy_shift().
    ** That gives a significant speed improvement. */
    if( yysize ){
      yypParser->yyidx++;
      yymsp -= yysize-1;
      yymsp->stateno = (YYACTIONTYPE)yyact;
      yymsp->major = (YYCODETYPE)yygoto;
      yymsp->minor = yygotominor;
    }else
#endif
    {
      yy_shift(yypParser,yyact,yygoto,&yygotominor);
    }
  }else{
    assert( yyact == YYNSTATE + YYNRULE + 1 );
    yy_accept(yypParser);
  }
}

/*
** The following code executes when the parse fails
*/
#ifndef YYNOERRORRECOVERY
static void yy_parse_failed(
  yyParser *yypParser           /* The parser */
){
  TOMLParserARG_FETCH;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sFail!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser fails */
 _TOML_fillError( state->token, state, TOML_ERROR_FATAL );
  TOMLParserARG_STORE; /* Suppress warning about unused %extra_argument variable */
}
#endif /* YYNOERRORRECOVERY */

/*
** The following code executes when a syntax error first occurs.
*/
static void yy_syntax_error(
  yyParser *yypParser,           /* The parser */
  int yymajor,                   /* The major type of the error token */
  YYMINORTYPE yyminor            /* The minor type of the error token */
){
  TOMLParserARG_FETCH;
#define TOKEN (yyminor.yy0)
  TOMLParserARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/*
** The following is executed when the parser accepts
*/
static void yy_accept(
  yyParser *yypParser           /* The parser */
){
  TOMLParserARG_FETCH;
#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sAccept!\n",yyTracePrompt);
  }
#endif
  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);
  /* Here code is inserted which will be executed whenever the
  ** parser accepts */
  TOMLParserARG_STORE; /* Suppress warning about unused %extra_argument variable */
}

/* The main parser program.
** The first argument is a pointer to a structure obtained from
** "TOMLParserAlloc" which describes the current state of the parser.
** The second argument is the major token number.  The third is
** the minor token.  The fourth optional argument is whatever the
** user wants (and specified in the grammar) and is available for
** use by the action routines.
**
** Inputs:
** <ul>
** <li> A pointer to the parser (an opaque structure.)
** <li> The major token number.
** <li> The minor token number.
** <li> An option argument of a grammar-specified type.
** </ul>
**
** Outputs:
** None.
*/
void TOMLParser(
  void *yyp,                   /* The parser */
  int yymajor,                 /* The major token code number */
  TOMLParserTOKENTYPE yyminor       /* The value for the token */
  TOMLParserARG_PDECL               /* Optional %extra_argument parameter */
){
  YYMINORTYPE yyminorunion;
  int yyact;            /* The parser action. */
  int yyendofinput;     /* True if we are at the end of input */
#ifdef YYERRORSYMBOL
  int yyerrorhit = 0;   /* True if yymajor has invoked an error */
#endif
  yyParser *yypParser;  /* The parser */

  /* (re)initialize the parser, if necessary */
  yypParser = (yyParser*)yyp;
  if( yypParser->yyidx<0 ){
#if YYSTACKDEPTH<=0
    if( yypParser->yystksz <=0 ){
      /*memset(&yyminorunion, 0, sizeof(yyminorunion));*/
      yyminorunion = yyzerominor;
      yyStackOverflow(yypParser, &yyminorunion);
      return;
    }
#endif
    yypParser->yyidx = 0;
    yypParser->yyerrcnt = -1;
    yypParser->yystack[0].stateno = 0;
    yypParser->yystack[0].major = 0;
  }
  yyminorunion.yy0 = yyminor;
  yyendofinput = (yymajor==0);
  TOMLParserARG_STORE;

#ifndef NDEBUG
  if( yyTraceFILE ){
    fprintf(yyTraceFILE,"%sInput %s\n",yyTracePrompt,yyTokenName[yymajor]);
  }
#endif

  do{
    yyact = yy_find_shift_action(yypParser,(YYCODETYPE)yymajor);
    if( yyact<YYNSTATE ){
      assert( !yyendofinput );  /* Impossible to shift the $ token */
      yy_shift(yypParser,yyact,yymajor,&yyminorunion);
      yypParser->yyerrcnt--;
      yymajor = YYNOCODE;
    }else if( yyact < YYNSTATE + YYNRULE ){
      yy_reduce(yypParser,yyact-YYNSTATE);
    }else{
      assert( yyact == YY_ERROR_ACTION );
#ifdef YYERRORSYMBOL
      int yymx;
#endif
#ifndef NDEBUG
      if( yyTraceFILE ){
        fprintf(yyTraceFILE,"%sSyntax Error!\n",yyTracePrompt);
      }
#endif
#ifdef YYERRORSYMBOL
      /* A syntax error has occurred.
      ** The response to an error depends upon whether or not the
      ** grammar defines an error token "ERROR".
      **
      ** This is what we do if the grammar does define ERROR:
      **
      **  * Call the %syntax_error function.
      **
      **  * Begin popping the stack until we enter a state where
      **    it is legal to shift the error symbol, then shift
      **    the error symbol.
      **
      **  * Set the error count to three.
      **
      **  * Begin accepting and shifting new tokens.  No new error
      **    processing will occur until three tokens have been
      **    shifted successfully.
      **
      */
      if( yypParser->yyerrcnt<0 ){
        yy_syntax_error(yypParser,yymajor,yyminorunion);
      }
      yymx = yypParser->yystack[yypParser->yyidx].major;
      if( yymx==YYERRORSYMBOL || yyerrorhit ){
#ifndef NDEBUG
        if( yyTraceFILE ){
          fprintf(yyTraceFILE,"%sDiscard input token %s\n",
             yyTracePrompt,yyTokenName[yymajor]);
        }
#endif
        yy_destructor(yypParser, (YYCODETYPE)yymajor,&yyminorunion);
        yymajor = YYNOCODE;
      }else{
         while(
          yypParser->yyidx >= 0 &&
          yymx != YYERRORSYMBOL &&
          (yyact = yy_find_reduce_action(
                        yypParser->yystack[yypParser->yyidx].stateno,
                        YYERRORSYMBOL)) >= YYNSTATE
        ){
          yy_pop_parser_stack(yypParser);
        }
        if( yypParser->yyidx < 0 || yymajor==0 ){
          yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
          yy_parse_failed(yypParser);
          yymajor = YYNOCODE;
        }else if( yymx!=YYERRORSYMBOL ){
          YYMINORTYPE u2;
          u2.YYERRSYMDT = 0;
          yy_shift(yypParser,yyact,YYERRORSYMBOL,&u2);
        }
      }
      yypParser->yyerrcnt = 3;
      yyerrorhit = 1;
#elif defined(YYNOERRORRECOVERY)
      /* If the YYNOERRORRECOVERY macro is defined, then do not attempt to
      ** do any kind of error recovery.  Instead, simply invoke the syntax
      ** error routine and continue going as if nothing had happened.
      **
      ** Applications can set this macro (for example inside %include) if
      ** they intend to abandon the parse upon the first syntax error seen.
      */
      yy_syntax_error(yypParser,yymajor,yyminorunion);
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      yymajor = YYNOCODE;

#else  /* YYERRORSYMBOL is not defined */
      /* This is what we do if the grammar does not define ERROR:
      **
      **  * Report an error message, and throw away the input token.
      **
      **  * If the input token is $, then fail the parse.
      **
      ** As before, subsequent error messages are suppressed until
      ** three input tokens have been successfully shifted.
      */
      if( yypParser->yyerrcnt<=0 ){
        yy_syntax_error(yypParser,yymajor,yyminorunion);
      }
      yypParser->yyerrcnt = 3;
      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);
      if( yyendofinput ){
        yy_parse_failed(yypParser);
      }
      yymajor = YYNOCODE;
#endif
    }
  }while( yymajor!=YYNOCODE && yypParser->yyidx>=0 );
  return;
}
#include <assert.h>
#include <math.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// #include <antlr3.h>

#include "toml.h"
// #include "tomlParser.h"
// #include "tomlLexer.h"

struct _TOMLStringifyData {
  TOMLError *error;

  int bufferSize;
  int bufferIndex;
  char *buffer;
  int tableNameDepth;
  int tableNameStackSize;
  TOMLString **tableNameStack;
};

int _TOML_stringify( struct _TOMLStringifyData *self, TOMLRef src );

TOMLRef TOML_alloc( TOMLType type ) {
  switch ( type ) {
    case TOML_TABLE:
      return TOML_allocTable( NULL, NULL );
    case TOML_ARRAY:
      return TOML_allocArray( TOML_NOTYPE );
    case TOML_STRING:
      return TOML_allocString( "" );
    case TOML_INT:
      return TOML_allocInt( 0 );
    case TOML_DOUBLE:
      return TOML_allocDouble( 0 );
    case TOML_BOOLEAN:
      return TOML_allocBoolean( 0 );
    case TOML_DATE:
      return TOML_allocEpochDate( 0 );
    default:
      return NULL;
  }
}

void _TOMLTable_partition( TOMLTable *self ) {
  int j = 0;
  int i;
  for ( i = 0; i < self->keys->size; ++i ) {
    TOMLBasic *value = TOMLArray_getIndex( self->values, i );
    if ((value->type != TOML_ARRAY ||
         ((TOMLArray *)value)->memberType != TOML_TABLE) &&
        value->type != TOML_TABLE) {
        if (i != j) {
            TOMLArray *k = TOMLArray_getIndex(self->keys, j);
            TOMLArray *v = TOMLArray_getIndex(self->values, j);
            self->keys->members[j] = TOMLArray_getIndex(self->keys, i);
            self->values->members[j] = TOMLArray_getIndex(self->values, i);
            self->keys->members[i] = k;
            self->values->members[i] = v;
        }
        ++j;
    }
  }
}

TOMLTable * TOML_allocTable( TOMLString *key, TOMLRef value, ... ) {
  TOMLTable *self = malloc( sizeof(TOMLTable) );
  self->type = TOML_TABLE;
  self->keys = TOML_allocArray( TOML_STRING, NULL );
  self->values = TOML_allocArray( TOML_NOTYPE, NULL );

  if ( key != NULL ) {
    TOMLArray_append( self->keys, key );
    TOMLArray_append( self->values, value );
  } else {
    return self;
  }

  va_list args;
  va_start( args, value );

  key = va_arg( args, TOMLString * );
  while ( key != NULL ) {
    value = va_arg( args, TOMLRef );
    TOMLArray_append( self->keys, key );
    TOMLArray_append( self->values, value );
    key = va_arg( args, TOMLString * );
  }

  va_end( args );

  return self;
}

TOMLArray * TOML_allocArray( TOMLType memberType, ... ) {
  TOMLArray *self = malloc( sizeof(TOMLArray) );
  self->type = TOML_ARRAY;
  self->memberType = memberType;
  self->size = 0;
  self->members = NULL;

  va_list args;
  va_start( args, memberType );

  TOMLRef member = va_arg( args, TOMLRef );
  while ( member != NULL ) {
    TOMLArray_append( self, member );
    member = va_arg( args, TOMLRef );
  }

  va_end( args );

  return self;
}

TOMLString * TOML_allocString( const char *content ) {
  int size = strlen( content );
  TOMLString *self = malloc( sizeof(TOMLString) + size + 1 );
  self->type = TOML_STRING;
  self->size = size;
  self->content[ self->size ] = 0;
  strncpy( self->content, content, size );

  return self;
}

TOMLString * TOML_allocStringN( char *content, int n ) {
  TOMLString *self = malloc( sizeof(TOMLString) + n + 1 );
  self->type = TOML_STRING;
  self->size = n;
  self->content[ n ] = 0;
  strncpy( self->content, content, n );

  return self;
}

TOMLNumber * TOML_allocInt( int value ) {
  TOMLNumber *self = malloc( sizeof(TOMLNumber) );
  self->type = TOML_INT;
  // self->numberType = TOML_INT;
  self->intValue = value;

  return self;
}

TOMLNumber * TOML_allocDouble( double value ) {
  TOMLNumber *self = malloc( sizeof(TOMLNumber) );
  self->type = TOML_DOUBLE;
  // self->numberType = TOML_DOUBLE;
  self->doubleValue = value;

  return self;
}

TOMLBoolean * TOML_allocBoolean( int truth ) {
  TOMLBoolean *self = malloc( sizeof(TOMLBoolean) );
  self->type = TOML_BOOLEAN;
  self->isTrue = truth;
  return self;
}

int _TOML_isLeapYear( int year ) {
  if ( year % 400 == 0 ) {
    return 1;
  } else if ( year % 100 == 0 ) {
    return 0;
  } else if ( year % 4 == 0 ) {
    return 1;
  } else {
    return 0;
  }
}

TOMLDate * TOML_allocDate(
  int year, int month, int day, int hour, int minute, int second
) {
  TOMLDate *self = malloc( sizeof(TOMLDate) );
  self->type = TOML_DATE;

  self->year = year;
  self->month = month;
  self->day = day;

  self->hour = hour;
  self->minute = minute;
  self->second = second;

  struct tm _time = {
    second,
    minute,
    hour,
    day,
    month,
    year - 1900
  };

  // local time
  time_t localEpoch = mktime( &_time );
  // gm time
  _time = *gmtime( &localEpoch );
  time_t gmEpoch = mktime( &_time );

  double diff = difftime( localEpoch, gmEpoch );

  // Adjust the localEpock made by mktime to a gmt epoch.
  self->sinceEpoch = localEpoch + diff;

  return self;
}

TOMLDate * TOML_allocEpochDate( time_t stamp ) {
  TOMLDate *self = malloc( sizeof(TOMLDate) );
  self->type = TOML_DATE;
  self->sinceEpoch = stamp;

  struct tm _time = *gmtime( &stamp );

  self->second = _time.tm_sec;
  self->minute = _time.tm_min;
  self->hour = _time.tm_hour;
  self->day = _time.tm_mday;
  self->month = _time.tm_mon;
  self->year = _time.tm_year + 1900;

  return self;
}

TOMLError * TOML_allocError( int code ) {
  TOMLError *self = malloc( sizeof(TOMLError) );
  self->type = TOML_ERROR;
  self->code = code;
  self->lineNo = 0;
  self->line = NULL;
  self->message = NULL;
  self->fullDescription = NULL;

  return self;
}

char * _TOML_cstringCopy( char *str ) {
  if ( !str ) {
    return NULL;
  }

  int size = strlen( str );
  char *newstr = malloc( size + 1 );
  newstr[ size ] = 0;
  strncpy( newstr, str, size );

  return newstr;
}

TOMLRef TOML_copy( TOMLRef self ) {
  TOMLBasic *basic = (TOMLBasic *) self;

  if ( basic->type == TOML_TABLE ) {
    TOMLTable *table = (TOMLTable *) self;
    TOMLTable *newTable = malloc( sizeof(TOMLTable) );
    newTable->type = TOML_TABLE;
    newTable->keys = TOML_copy( table->keys );
    newTable->values = TOML_copy( table->values );
    return newTable;
  } else if ( basic->type == TOML_ARRAY ) {
    TOMLArray *array = (TOMLArray *) self;
    TOMLArray *newArray = malloc( sizeof(TOMLArray) );
    newArray->type = TOML_ARRAY;
    newArray->memberType = array->memberType;
    int i;
    for ( i = 0; i < array->size; ++i ) {
      TOMLArray_append(
        newArray,
        TOML_copy( TOMLArray_getIndex( array, i ) )
      );
    }
    return newArray;
  } else if ( basic->type == TOML_STRING ) {
    TOMLString *string = (TOMLString *) self;
    TOMLString *newString = malloc( sizeof(TOMLString) + string->size + 1 );
    newString->type = TOML_STRING;
    newString->size = string->size;
    strncpy( newString->content, string->content, string->size + 1 );
    return newString;
  } else if ( basic->type == TOML_INT || basic->type == TOML_DOUBLE ) {
    TOMLNumber *number = (TOMLNumber *) self;
    TOMLNumber *newNumber = malloc( sizeof(TOMLNumber) );
    newNumber->type = number->type;
    // newNumber->numberType = number->numberType;
    memcpy( newNumber->bytes, number->bytes, 8 );
    return newNumber;
  } else if ( basic->type == TOML_BOOLEAN ) {
    TOMLBoolean *boolean = (TOMLBoolean *) self;
    TOMLBoolean *newBoolean = malloc( sizeof(TOMLBoolean) );
    newBoolean->type = boolean->type;
    newBoolean->isTrue = boolean->isTrue;
    return newBoolean;
  } else if ( basic->type == TOML_DATE ) {
    TOMLDate *date = (TOMLDate *) self;
    TOMLDate *newDate = malloc( sizeof(TOMLDate) );
    *newDate = *date;
    return newDate;
  } else if ( basic->type == TOML_ERROR ) {
    TOMLError *error = (TOMLError *) self;
    TOMLError *newError = malloc( sizeof(TOMLError) );
    newError->type = TOML_ERROR;
    newError->code = error->code;
    newError->lineNo = error->lineNo;
    newError->line = _TOML_cstringCopy( error->line );
    newError->message = _TOML_cstringCopy( error->message );
    newError->fullDescription = _TOML_cstringCopy( error->fullDescription );
    return newError;
  } else {
    return NULL;
  }
}

void TOML_free( TOMLRef self ) {
  TOMLBasic *basic = (TOMLBasic *) self;

  if ( basic->type == TOML_TABLE ) {
    TOMLTable *table = (TOMLTable *) self;
    TOML_free( table->keys );
    TOML_free( table->values );
  } else if ( basic->type == TOML_ARRAY ) {
    TOMLArray *array = (TOMLArray *) self;
    int i;
    for ( i = 0; i < array->size; ++i ) {
      TOML_free( array->members[ i ] );
    }
    free( array->members );
  } else if ( basic->type == TOML_ERROR ) {
    TOMLError *error = (TOMLError *) self;
    free( error->line );
    free( error->message );
    free( error->fullDescription );
  }

  free( self );
}

int TOML_isType( TOMLRef self, TOMLType type ) {
  TOMLBasic *basic = (TOMLBasic *) self;
  return basic->type == type;
}

int TOML_isNumber( TOMLRef self ) {
  TOMLBasic *basic = (TOMLBasic *) self;
  return basic->type == TOML_INT || basic->type == TOML_DOUBLE;
}

TOMLRef TOML_find( TOMLRef self, ... ) {
  TOMLBasic *basic = self;
  va_list args;
  va_start( args, self );

  char *key;

  do {
    if ( basic->type == TOML_TABLE ) {
      key = va_arg( args, char * );
      if ( key == NULL ) {
        break;
      }
      basic = self = TOMLTable_getKey( self, key );
    } else if ( basic->type == TOML_ARRAY ) {
      key = va_arg( args, char * );
      if ( key == NULL ) {
        break;
      }
      basic = self = TOMLArray_getIndex( self, atoi( key ) );
    } else {
      break;
    }
  } while ( self );

  va_end( args );
  return self;
}

TOMLRef TOMLTable_getKey( TOMLTable *self, const char *key ) {
  int keyLength = strlen( key );
  int i;
  for ( i = 0; i < self->keys->size; ++i ) {
    TOMLString *tableKey = TOMLArray_getIndex( self->keys, i );
    int minSize = keyLength < tableKey->size ? keyLength : tableKey->size;
    if ( strncmp( tableKey->content, key, minSize + 1 ) == 0 ) {
      return TOMLArray_getIndex( self->values, i );
    }
  }
  return NULL;
}

void TOMLTable_setKey( TOMLTable *self, const char *key, TOMLRef value ) {
  int keyLength = strlen( key );
  int i;
  for ( i = 0; i < self->keys->size; ++i ) {
    TOMLString *tableKey = TOMLArray_getIndex( self->keys, i );
    int minSize = keyLength < tableKey->size ? keyLength : tableKey->size;
    if ( strncmp( tableKey->content, key, minSize + 1 ) == 0 ) {
      TOMLArray_setIndex( self->values, i, value );
      return;
    }
  }

  TOMLArray_append( self->keys, TOML_allocString( key ) );
  TOMLArray_append( self->values, value );
}

TOMLRef TOMLArray_getIndex( TOMLArray *self, int index ) {
  return self->members && self->size > index ? self->members[ index ] : NULL;
}

void TOMLArray_setIndex( TOMLArray *self, int index, TOMLRef value ) {
  if ( index < self->size ) {
    TOML_free( self->members[ index ] );
    self->members[ index ] = value;
  } else {
    TOMLArray_append( self, value );
  }
}

void TOMLArray_append( TOMLArray *self, TOMLRef value ) {
  assert( self->memberType == TOML_NOTYPE ||
          TOML_isType(value, self->memberType) );

  TOMLRef *newMembers = realloc(self->members,
                                ( self->size + 1 ) * sizeof(TOMLRef) );
  if (newMembers != NULL) {
      self->members = newMembers;
      self->members[ self->size++ ] = value;
  }
}

char * TOML_toString( TOMLString *self ) {
  char *string = malloc( self->size + 1 );
  TOML_copyString( self, self->size + 1, string );
  return string;
}

const char * TOML_getString( TOMLString *self ) {
  return self->content;
}

#define RETURN_VALUE switch ( self->type ) { \
    case TOML_INT: \
      return self->intValue; \
    case TOML_DOUBLE: \
      return self->doubleValue; \
    default: \
      return 0; \
  }

int TOML_toInt( TOMLNumber *self ) {
  RETURN_VALUE;
}

double TOML_toDouble( TOMLNumber *self ) {
  RETURN_VALUE;
}

#undef RETURN_VALUE

struct tm TOML_toTm( TOMLDate *self ) {
  return *gmtime( &self->sinceEpoch );
}

int TOML_toBoolean( TOMLBoolean *self ) {
  return self->isTrue;
}

TOMLToken * TOML_newToken( TOMLToken *token ) {
  TOMLToken *heapToken = malloc( sizeof(TOMLToken) );
  memcpy( heapToken, token, sizeof(TOMLToken) );

  int size = token->end - token->start;
  heapToken->tokenStr = malloc( size + 1 );
  heapToken->tokenStr[ size ] = 0;
  strncpy( heapToken->tokenStr, token->start, size );

  return heapToken;
}

void TOML_strcpy( char *buffer, TOMLString *self, int size ) {
  if ( self->type != TOML_STRING ) {
    buffer[0] = 0;
  } else {
    strncpy(
      buffer, self->content, size < self->size + 1 ? size : self->size + 1
    );
  }
}

char * _TOML_increaseBuffer( char *oldBuffer, int *size ) {
  int newSize = *size + 1024;
  char *newBuffer = realloc( oldBuffer, newSize + 1 );

  if ( newBuffer ) {
    // Always have a null terminator so TOMLScan can exit without segfault.
    newBuffer[*size] = 0;
    *size = newSize;
    return newBuffer;
  }

  return oldBuffer;
}

int TOML_load( char *filename, TOMLTable **dest, TOMLError *error ) {
  assert( *dest == NULL );

  FILE *fd = fopen( filename, "r" );
  if ( fd == NULL ) {
    if ( error ) {
      error->code = TOML_ERROR_FILEIO;
      error->lineNo = -1;
      error->line = NULL;

      int messageSize = strlen( TOMLErrorDescription[ error->code ] );
      error->message =
        malloc( messageSize + 1 );
      strcpy( error->message, TOMLErrorDescription[ error->code ] );
      error->message[ messageSize ] = 0;

      int fullDescSize = messageSize + strlen( filename ) + 8;
      error->fullDescription = malloc( fullDescSize + 1 );
      snprintf(
        error->fullDescription,
        fullDescSize,
        "%s File: %s",
        error->message,
        filename
      );
    }

    return TOML_ERROR_FILEIO;
  }

  int bufferSize = 0;
  char * buffer = _TOML_increaseBuffer( NULL, &bufferSize );
  int copyBufferSize = 0;
  char * copyBuffer = _TOML_increaseBuffer( NULL, &copyBufferSize );
  int read = fread( buffer, 1, bufferSize, fd );
  int incomplete = read == bufferSize;

  int hTokenId;
  TOMLToken token = { 0, NULL, NULL, buffer, 0, buffer, NULL };
  TOMLToken lastToken = token;

  TOMLTable *topTable = *dest = TOML_allocTable( NULL, NULL );
  TOMLParserState state = { topTable, topTable, 0, error, &token };

  pTOMLParser parser = TOMLParserAlloc( malloc );

  while (
    state.errorCode == 0 && (
      TOMLScan( token.end, &hTokenId, &token ) || incomplete
    )
  ) {
    while ( token.end >= buffer + bufferSize && incomplete ) {
      int lineSize = buffer + bufferSize - lastToken.lineStart;

      if ( lastToken.lineStart == buffer ) {
        strncpy( copyBuffer, lastToken.lineStart, lineSize );
        buffer = _TOML_increaseBuffer( buffer, &bufferSize );
        copyBuffer = _TOML_increaseBuffer( copyBuffer, &copyBufferSize );
        strncpy( buffer, copyBuffer, lineSize );
      } else {
        strncpy( copyBuffer, lastToken.lineStart, lineSize );
        strncpy( buffer, copyBuffer, lineSize );
      }

      int read = fread( buffer + lineSize, 1, bufferSize - lineSize, fd );
      incomplete = read == bufferSize - lineSize;
      if ( !incomplete ) {
        buffer[ lineSize + read ] = 0;
      }

      token = lastToken;
      token.end = buffer + ( token.end - token.lineStart );
      token.lineStart = buffer;
      lastToken = token;
      TOMLScan( token.end, &hTokenId, &token );
    }

    lastToken = token;

    int tmpSize = token.end - token.start;
    char *tmp = malloc( tmpSize + 1 );
    strncpy( tmp, token.start, tmpSize );
    tmp[ tmpSize ] = 0;
    free( tmp );

    TOMLParser( parser, hTokenId, TOML_newToken( &token ), &state );
  }

  if ( state.errorCode == 0 ) {
    TOMLParser( parser, hTokenId, TOML_newToken( &token ), &state );
  }

  TOMLParserFree( parser, free );

  free( copyBuffer );
  free( buffer );
  fclose( fd );

  if ( state.errorCode != 0 ) {
    TOML_free( *dest );
    *dest = NULL;
    return state.errorCode;
  }

  return 0;
}

// int TOML_dump( char *filename, TOMLTable * );

int TOML_parse( char *buffer, TOMLTable **dest, TOMLError *error ) {
  assert( *dest == NULL );

  int hTokenId;
  TOMLToken token = { 0, NULL, NULL, buffer, 0, buffer, NULL };

  TOMLTable *topTable = *dest = TOML_allocTable( NULL, NULL );
  TOMLParserState state = { topTable, topTable, 0, error, &token };

  pTOMLParser parser = TOMLParserAlloc( malloc );

  while ( state.errorCode == 0 && TOMLScan( token.end, &hTokenId, &token ) ) {
    TOMLParser( parser, hTokenId, TOML_newToken( &token ), &state );
  }

  if ( state.errorCode == 0 ) {
    TOMLParser( parser, hTokenId, TOML_newToken( &token ), &state );
  }

  TOMLParserFree( parser, free );

  if ( state.errorCode != 0 ) {
    TOML_free( *dest );
    *dest = NULL;
    return state.errorCode;
  }

  return 0;
}

TOMLString ** _TOML_increaseNameStack(
  TOMLString **nameStack, int *nameStackSize
) {
  TOMLString **oldStack = nameStack;
  int oldSize = *nameStackSize;
  *nameStackSize += 16;
  nameStack = malloc( *nameStackSize * sizeof(TOMLString *) );
  if ( oldStack ) {
    memcpy( nameStack, oldStack, oldSize );
    free( oldStack );
  }
  return nameStack;
}

void _TOML_stringifyPushName(
  struct _TOMLStringifyData *self, TOMLRef src
) {
  if ( self->tableNameDepth >= self->tableNameStackSize ) {
    self->tableNameStack = _TOML_increaseNameStack(
      self->tableNameStack,
      &( self->tableNameStackSize )
    );
  }
  self->tableNameStack[ self->tableNameDepth ] = src;
  self->tableNameDepth++;
}

void _TOML_stringifyPopName(
  struct _TOMLStringifyData *self
) {
  self->tableNameDepth--;
  self->tableNameStack[ self->tableNameDepth ] = NULL;
}

void _TOML_stringifyText( struct _TOMLStringifyData *self, char *text, int n ) {
  if ( self->bufferIndex + n + 1 >= self->bufferSize ) {
    self->buffer = _TOML_increaseBuffer( self->buffer, &self->bufferSize );
  }
  strncpy( self->buffer + self->bufferIndex, text, n );
  self->bufferIndex += n;
  self->buffer[ self->bufferIndex ] = 0;
}

void _TOML_stringifyTableHeader(
  struct _TOMLStringifyData *self, TOMLTable *table
) {
  TOMLBasic *first = TOMLArray_getIndex( table->values, 0 );
  if (
    !first ||
      first->type == TOML_TABLE || (
      first->type == TOML_ARRAY &&
      ((TOMLArray *) first)->memberType == TOML_TABLE
    )
  ) {
    return;
  }

  if ( self->bufferIndex != 0 ) {
    _TOML_stringifyText( self, "\n", 1 );
  }

  _TOML_stringifyText( self, "[", 1 );
  for ( int i = 0; i < self->tableNameDepth; ++i ) {
    TOMLString *tableName = self->tableNameStack[ i ];
    if ( i > 0 ) {
      _TOML_stringifyText( self, ".", 1 );
    }
    _TOML_stringifyText( self, tableName->content, tableName->size );
  }
  _TOML_stringifyText( self, "]\n", 2 );
}

void _TOML_stringifyArrayHeader( struct _TOMLStringifyData *self ) {
  if ( self->bufferIndex != 0 ) {
    _TOML_stringifyText( self, "\n", 1 );
  }

  _TOML_stringifyText( self, "[[", 2 );
  for ( int i = 0; i < self->tableNameDepth; ++i ) {
    TOMLString *tableName = self->tableNameStack[ i ];
    if ( i > 0 ) {
      _TOML_stringifyText( self, ".", 1 );
    }
    _TOML_stringifyText( self, tableName->content, tableName->size );
  }
  _TOML_stringifyText( self, "]]\n", 3 );
}

void _TOML_stringifyString(
  struct _TOMLStringifyData *self, TOMLString *string
) {
  char *cursor = string->content;
  while ( cursor != NULL ) {
    // Scan for escapable character or unicode.
    char *next = cursor;
    unsigned int ch = *next;
    for ( ;
      !(
        ch == 0 ||
          ch == '\b' ||
          ch == '\t' ||
          ch == '\f' ||
          ch == '\n' ||
          ch == '\r' ||
          ch == '"' ||
          ch == '\\' ||
          ch > 0x7f
      );
      next++, ch = *next
    ) {}

    if ( *next == 0 ) {
      next = NULL;
    }

    // Copy text up to character and then insert escaped character.
    if ( next ) {
      _TOML_stringifyText( self, cursor, next - cursor );

      #define REPLACE( match, value ) \
      if ( *next == match ) { \
        _TOML_stringifyText( self, value, 2 ); \
      }
      REPLACE( '\b', "\\b" )
      else REPLACE( '\t', "\\t" )
      else REPLACE( '\f', "\\f" )
      else REPLACE( '\n', "\\n" )
      else REPLACE( '\r', "\\r" )
      else REPLACE( '"', "\\\"" )
      else REPLACE( '\\', "\\\\" )
      #undef REPLACE
      else if ( ((unsigned int) *next ) > 0x7f ) {
        int num = 0;
        int chsize;

        // Decode the numeric representation of the utf8 character
        if ( ( *next & 0xe0 ) == 0xe0 ) {
          chsize = 3;
          num =
            ( ( next[0] & 0x0f ) << 12 ) |
              ( ( next[1] & 0x3f ) << 6 ) |
              ( next[2] & 0x3f );
        } else if ( ( *next & 0xc0 ) == 0xc0 ) {
          chsize = 2;
          num =
            ( ( next[0] & 0x1f ) << 6 ) |
              ( next[1] & 0x3f );
        } else {
          assert( 0 );
        }

        // Stringify \uxxxx
        char utf8Buffer[5];
        snprintf( utf8Buffer, 5, "%04x", num );
        _TOML_stringifyText( self, "\\u", 2 );
        _TOML_stringifyText( self, utf8Buffer, 4 );

        next += chsize - 1;
      }

      next++;
    // Copy everything up to the end.
    } else {
      _TOML_stringifyText( self, cursor, strlen( cursor ) );
    }

    cursor = next;
  }
}

void _TOML_stringifyEntry(
  struct _TOMLStringifyData *self, TOMLString *key, TOMLBasic *value
) {
  _TOML_stringifyText( self, key->content, key->size );
  _TOML_stringifyText( self, "=", 1 );

  if ( value->type == TOML_STRING ) {
    _TOML_stringifyText( self, "\"", 1 );
    _TOML_stringifyString( self, (TOMLString *) value );
    _TOML_stringifyText( self, "\"", 1 );
  } else {
    _TOML_stringify( self, value );
  }

  _TOML_stringifyText( self, "\n", 1 );
}

int _TOML_stringify(
  struct _TOMLStringifyData *self, TOMLRef src
) {
  // Cast to TOMLBasic to discover type.
  TOMLBasic *basic = src;

  // if null
  if ( src == NULL ) {
    _TOML_stringifyText( self, "(null)", 6 );
  // if table
  } else if ( basic->type == TOML_TABLE ) {
    TOMLTable *table = src;
    _TOMLTable_partition( table );

    // loop keys
    for ( int i = 0; i < table->keys->size; ++i ) {
      TOMLRef key = TOMLArray_getIndex( table->keys, i );
      TOMLRef value = TOMLArray_getIndex( table->values, i  );
      TOMLBasic *basicValue = value;

      // if value is table, print header, recurse
      if ( basicValue->type == TOML_TABLE ) {
        _TOML_stringifyPushName( self, key );
        _TOML_stringifyTableHeader( self, value );
        _TOML_stringify( self, value );
        _TOML_stringifyPopName( self );
      // if value is array
      } else if ( basicValue->type == TOML_ARRAY ) {
        TOMLArray *array = value;

        // if value is object array
        if ( array->memberType == TOML_TABLE ) {
          // loop indices, print headers, recurse
          for ( int j = 0; j < array->size; ++j ) {
            _TOML_stringifyPushName( self, key );
            _TOML_stringifyArrayHeader( self );
            _TOML_stringify( self, TOMLArray_getIndex( array, j ) );
            _TOML_stringifyPopName( self );
          }
        } else {
          // print entry line with dense (no newlines) array
          _TOML_stringifyEntry( self, key, value );
        }
      } else {
        // if value is string or number, print entry
        _TOML_stringifyEntry( self, key, value );
      }
    }
  // if array
  } else if ( basic->type == TOML_ARRAY ) {
    TOMLArray *array = src;

    // print array densely
    _TOML_stringifyText( self, "[", 1 );
    for ( int i = 0; i < array->size; ++i ) {
      TOMLBasic *arrayValue = TOMLArray_getIndex( array, i );
      if ( arrayValue->type == TOML_STRING ) {
        _TOML_stringifyText( self, "\"", 1 );
        _TOML_stringifyString( self, (TOMLString *) arrayValue );
        _TOML_stringifyText( self, "\"", 1 );
      } else {
        _TOML_stringify( self, arrayValue );
      }
      if ( i != array->size - 1 ) {
        _TOML_stringifyText( self, ",", 1 );
      }
    }
    _TOML_stringifyText( self, "]", 1 );
  // if string
  } else if ( basic->type == TOML_STRING ) {
    TOMLString *string = src;

    // print string
    _TOML_stringifyText( self, string->content, string->size );
  // if number
  } else if ( TOML_isNumber( basic ) ) {
    TOMLNumber *number = src;
    char numberBuffer[ 16 ];
    memset( numberBuffer, 0, 16 );

    int size;
    if ( number->type == TOML_INT ) {
      size = snprintf( numberBuffer, 15, "%d", number->intValue );
    } else if ( fmod( number->doubleValue, 1 ) == 0 ) {
      size = snprintf( numberBuffer, 15, "%.1f", number->doubleValue );
    } else {
      size = snprintf( numberBuffer, 15, "%g", number->doubleValue );
    }

    // print number
    _TOML_stringifyText( self, numberBuffer, size );
  } else if ( basic->type == TOML_BOOLEAN ) {
    TOMLBoolean *boolean = (TOMLBoolean *) basic;

    if ( boolean->isTrue ) {
      _TOML_stringifyText( self, "true", 4 );
    } else {
      _TOML_stringifyText( self, "false", 5 );
    }
  } else if ( basic->type == TOML_DATE ) {
    TOMLDate *date = (TOMLDate *) basic;
    char numberBuffer[ 16 ];
    int size;

    #define STRINGIFY_DATE_SECTION( format, part, spacer ) \
      size = snprintf( numberBuffer, 15, format, date->part ); \
      _TOML_stringifyText( self, numberBuffer, size ); \
      _TOML_stringifyText( self, spacer, 1 )

    STRINGIFY_DATE_SECTION( "%d", year, "-" );
    STRINGIFY_DATE_SECTION( "%02d", month, "-" );
    STRINGIFY_DATE_SECTION( "%02d", day, "T" );
    STRINGIFY_DATE_SECTION( "%02d", hour, ":" );
    STRINGIFY_DATE_SECTION( "%02d", minute, ":" );
    STRINGIFY_DATE_SECTION( "%02d", second, "Z" );

    #undef STRINGIFY_DATE_SECTION
  } else {
    assert( 0 );
  }
  // if error
    // print error

  return 0;
}

int TOML_stringify( char **buffer, TOMLRef src, TOMLError *error ) {
  int bufferSize = 0;
  char *output = _TOML_increaseBuffer( NULL, &bufferSize );

  int stackSize = 0;
  TOMLString **tableNameStack = _TOML_increaseNameStack( NULL, &stackSize );

  struct _TOMLStringifyData stringifyData = {
    error,

    bufferSize,
    0,
    output,
    0,
    stackSize,
    tableNameStack
  };

  int errorCode = _TOML_stringify( &stringifyData, src );

  free( tableNameStack );
  *buffer = stringifyData.buffer;

  return errorCode;
}
